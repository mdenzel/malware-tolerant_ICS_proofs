#!/bin/bash

#
#  @title:    Self-healing Industrial Control System
#  @authors:  Michael Denzel <md.research@mailbox.org>
#  @date:     2016-07-14
#
#  Shellscript to run generated ProVerif proofs of selfhealing_proverif.gen
#

### CONFIG ###
#to exchange with statverif (if needed)
PROGRAM=proverif
##############

#checks
if [ $# -ne 1 ]; then
    echo "usage: $0 <directory>"
    exit -1
fi
echo "running $PROGRAM"

#print in filtered way
function pv_print(){
    
    #check first iteration    
    substring="RESULT event\(a1_result\(b[_0-9]*\)\) ==> event\(sensor_start\(b[_0-9]*\)\) is true\."
    if [[ $1 =~ $substring ]]; then
        echo -en "    YES     "
    else
        echo -en "    NO      "
    fi

    #check second iteration
    substring="RESULT event\(a2_result\(b[_0-9]*\)\) ==> event\(a1_result\(b[_0-9]*\)\) is true\."
    if [[ $1 =~ $substring ]]; then
        echo -en "        YES      "
    else
        echo -en "        NO       "
    fi

    #check misbehaving plc_i gets reset
    # RESULT event(reset(i_29195)) ==> (event(result_ok(i_29195,x)) && event(sensor_start(b_29196)) && x <> b_29196) is true.
    substring="RESULT event\(reset\(i[_0-9]*\)\) ==> \(event\(result_ok\(i[_0-9]*,x[_0-9]*\)\) \&\& event\(sensor_start\(b[_0-9]*\)\) \&\& x[_0-9]* <> b[_0-9]*\) is true\."
    if [[ $1 =~ $substring ]]; then
        echo -en "      YES     "
    else
        echo -en "      NO      "
    fi

    #check honest plc_i gets not_reset
    # RESULT event(not_reset(i)) ==> (event(result_ok(i,b)) && event(sensor_start(b))) is true.
    substring="RESULT event\(not_reset\(i[_0-9]*\)\) ==> \(event\(result_ok\(i[_0-9]*,b[_0-9]*\)\) \&\& event\(sensor_start\(b[_0-9]*\)\)\) is true\."
    if [[ $1 =~ $substring ]]; then
        echo -en "      YES      "
    else
        echo -en "      NO       "
    fi    
    
    #check for success
    substring="RESULT not attacker(_p[0-9]*)?\((cells\(state_[0-9]*\),)?success\[\]\)\ (is false|cannot be proved)\."
    if [[ $1 =~ $substring ]]; then
        echo "     success"
    else
        echo "       NO"
    fi
}


#get files (`-v` = "natural sort" => sort numbers correctly)
files=`ls -v $1/*.pv`

#print header
echo "running folder: $1"
printf "\n%-29s| %s | %s | %s | %s | %s\n" file "1st iteration" "2nd iteration" "type I error" "type II error" "run-through"
echo "---------------------------------------------------------------------------------------------------------"
#iterte over them
for f in $files; do
    #print file (without path)
    fx=`echo $f | cut -f3 -d"/"`
    printf "%-32s" $fx

    #call proverif
    filter='grep -B 1 "RESULT"'
    res=`$PROGRAM $f | sed '/^\s*$/ d' | eval "$filter"`

    #print in a filtered way (as "table")
    res=`echo $res` #kill new lines '\n'
    pv_print "$res"
done
