(*
TODO: this is an experimental StatVerif proof which does not work yet as StatVerif had to be adjusted.

#if FALSE

  @title:    Self-healing Industrial Control System
  @authors:  Michael Denzel <md.research@mailbox.org>
  @date:     2016-07-14

  Warning: this is a raw file to generate ProVerif proofs.
  It includes C-macros and is not intended to be run directly.
  Please use the appended shellscript to generate the code.

#else
  GENERATED FILE

  @title:    Self-healing Industrial Control System
  @authors:  Michael Denzel <md.research@mailbox.org>
  @date:     __DATE__

#endif
*)

(* ###################### CONFIG SECTION ###################### *)
(*set reconstructTrace = true.*) (* REMARK: traces sometimes cannot be created;
                                         rather use proof output *)
set verboseRules = true. (* print every single rule *)
(*set explainDerivation = false.*)
(* ############################################################ *)

(* defines *)
type char.
type int.
type skey.
type pkey.
type key. (* symmetric key *)
type sig.

(* #################### XXX: trust model #################### *)
    (* global variables *)
    const policy:       int.
    const plc1:         int.
    const plc2:         int.
    const plc3:         int.

    (* channels *)
    (* sensor/actuator is always honest since this is the device we protect *)
    (* => no channels here *)

    (* PLC1 *)
#if (PLC1_COMPR)
    free k1:            skey    .          (* plc1 compromised *)
    free ch_s_plc1:     channel .          (* plc1 compromised *)
#else
    free k1:            skey    [private]. (* plc1 honest *)
    free ch_s_plc1:     channel [private]. (* plc1 honest *)
#endif
#if (PLC1_COMPR || _2oo3_COMPR)
    free ch_plc1_2oo3:  channel .          (* plc1 or 2oo3 compromised *)
#else
    free ch_plc1_2oo3:  channel [private]. (* plc1 and 2oo3 honest *)
#endif

    (* PLC2 *)
#if (PLC2_COMPR)
    free k2:            skey    .          (* plc2 compromised *)
    free ch_s_plc2:     channel .          (* plc2 compromised *)
#else
    free k2:            skey    [private]. (* plc2 honest *)
    free ch_s_plc2:     channel [private]. (* plc2 honest *)
#endif
#if (PLC2_COMPR || _2oo3_COMPR)
    free ch_plc2_2oo3:  channel .          (* plc2 or 2oo3 compromised *)
#else
    free ch_plc2_2oo3:  channel [private]. (* plc2 and 2oo3 honest *)
#endif

    (* PLC3 *)
#if (PLC3_COMPR)
    free k3:            skey    .          (* plc3 compromised *)
    free ch_s_plc3:     channel .          (* plc3 compromised *)
#else
    free k3:            skey    [private]. (* plc3 honest *)
    free ch_s_plc3:     channel [private]. (* plc3 honest *)
#endif
#if (PLC3_COMPR || _2oo3_COMPR)
    free ch_plc3_2oo3:  channel .          (* plc3 or 2oo3 compromised *)
#else
    free ch_plc3_2oo3:  channel [private]. (* plc3 and 2oo3 honest *)
#endif

    (* 2oo3 *)
#if (_2oo3_COMPR)
   free ch_2oo3_s:      channel .          (* 2oo3 compromised *)
#else
   free ch_2oo3_s:      channel [private]. (* 2oo3 honest *)
#endif

    (* R1 *)
#if (R1_COMPR || _2oo3_COMPR)
   free ch_2oo3_r1:     channel .          (* R1 or 2oo3 compromised *)
#else
   free ch_2oo3_r1:     channel [private]. (* R1 and 2oo3 honest *)
#endif

    (* R2 *)
#if (R2_COMPR || _2oo3_COMPR)
   free ch_2oo3_r2:     channel .          (* R2 or 2oo3 compromised *)
#else
   free ch_2oo3_r2:     channel [private]. (* R2 and 2oo3 honest *)
#endif


    (* R3 *)
#if (R3_COMPR || _2oo3_COMPR)
   free ch_2oo3_r3:     channel .          (* R3 or 2oo3 compromised *)
#else
   free ch_2oo3_r3:     channel [private]. (* R3 and 2oo3 honest *)
#endif


    (* global state *)
    cell state := (
                    ch_s_plc1, ch_plc1_2oo3, (* PLC1 *)
                    ch_s_plc2, ch_plc2_2oo3, (* PLC2 *)
                    ch_s_plc3, ch_plc3_2oo3  (* PLC3 *)
                  ).

(* ############################################################ *)


(* test variables to check if end of protocol etc. is reached *)
free success: bitstring [private].
free ch_pub: channel. (* public channel *)

(* Symmetric encryption *)
fun senc(key, bitstring): bitstring.
reduc forall kx:key, m:bitstring; sdec(kx, senc(kx, m)) = m.

(* Asymmetric encryption *)
fun pk(skey): pkey.
fun aenc(pkey, bitstring): bitstring.
reduc forall kx:skey, m:bitstring; adec(kx, aenc(pk(kx), m)) = m.

(* hash *)
fun mac(key, bitstring): bitstring.

(* signatures *)
fun sign(skey, bitstring): sig.
reduc forall kx:skey, m:bitstring; check(pk(kx),m,sign(kx,m)) = m.

(* addition *)
fun sub(int, int): int.
reduc forall a:int, b:int; add(sub(a,b),b) = a.
(* commutativity not possible in proverif => endless loop! *)

(* Type cast *)
fun k2b(key): bitstring.
reduc forall kx:key; b2k(k2b(kx)) = kx.
fun c2b(char): bitstring.
reduc forall cx:char; b2c(c2b(cx)) = cx.
fun i2b(int): bitstring.
reduc forall i:int; b2i(i2b(i)) = i.

(* events to define control flows *)
event sensor_start(int).
event a1_result(int).
event a2_result(int).
(* PLCs *)
event a1_plc(int, int).
event a2_plc(int, int).

(* #################### XXX: QUERIES #################### *)
(* protocol runs through *)
(* "not attacker(success)" should be false/cannot be proved! *)
query attacker(success).

(* correct control of sensor/actuator *)
query s:int;
      (event (a2_result(s)) ==> event (a1_result(s))).
query s:int;
      (event (a1_result(s)) ==> event (sensor_start(s))).

(* self-healing *)
(*
query s:int;
      event (a1_result(s)) ==> event (a1_plc(plc1, s)).
query s1:int, s2:int;
      event (a2_result(s2)) ==> (event (a1_result(s1)) ==> event (a2_plc(plc1, s2))).
*)

(* ###################################################### *)


(* sensor: generates (reads) new sensor value s *)
let sensor_actuator() =
    new s1: int;
    event sensor_start(policy);
    (* first iteration *)
    out(ch_s_plc1, (policy, s1));
    out(ch_s_plc2, (policy, s1));
    out(ch_s_plc3, (policy, s1));
    out(ch_pub, (policy, s1)); (* tell attacker *)
    in(ch_2oo3_s, a1: int);
    event a1_result(add(a1,s1));
    (* second iteration *)
    phase 1;
    new s2: int;
    let n = add(a1, s1) in
    out(ch_s_plc1, (n, s2));
    out(ch_s_plc2, (n, s2));
    out(ch_s_plc3, (n, s2));
    out(ch_pub, (n, s2)); (* tell attacker *)
    in(ch_2oo3_s, a2: int);
    event a2_result(add(a2,s2));
    (* done *)
    out(ch_pub, success).

(* programmable logic controller: calculates actuator value *)
let PLC(k: skey, i: int,
        ch_s_plc: channel, (* input *)
        ch_plc_2oo3: channel (* output *)
        ) =
    (* first iteration *)
    in(ch_s_plc, (n1: int, s1: int));
    event a1_plc(i, n1);
    let a1 = sub(policy, s1) in
    out(ch_plc_2oo3, a1); (* TODO: this value should maybe be signed for Rx otherwise 2oo3 can attack Rx, also values should have an ID to map them *)
    (* second iteration *)
    phase 1;
    in(ch_s_plc, (n2: int, s2: int));
    event a2_plc(i, n2);
    let a2 = sub(policy, s2) in
    out(ch_plc_2oo3, a2).
    
(* two-out-of-three circuit: combines results of PLCs *)
let c_2oo3(ch_2oo3_r1: channel, ch_2oo3_r2: channel, ch_2oo3_r3: channel) =
    (* first iteration *)
    in(ch_plc1_2oo3, a1_plc1: int);
    in(ch_plc2_2oo3, a1_plc2: int);
    in(ch_plc3_2oo3, a1_plc3: int);
    (* usually a1 would be signed here
    and normally go via the historian(s) *)
    out(ch_2oo3_r1, (a1_plc1, a1_plc2, a1_plc3));
    out(ch_2oo3_r2, (a1_plc1, a1_plc2, a1_plc3));
    out(ch_2oo3_r3, (a1_plc1, a1_plc2, a1_plc3));
    if a1_plc1 = a1_plc2 then out(ch_2oo3_s, a1_plc1);
    (* else if *) if a1_plc1 = a1_plc3 then out(ch_2oo3_s, a1_plc1);
    (* else if *) if a1_plc2 = a1_plc3 then out(ch_2oo3_s, a1_plc2);
    (* second iteration *)
    phase 1;
    in(ch_plc1_2oo3, a2_plc1: int);
    in(ch_plc2_2oo3, a2_plc2: int);
    in(ch_plc3_2oo3, a2_plc3: int);
    (* usually a1 would be signed here
    and normally go via the historian(s) *)
    out(ch_2oo3_r1, (a2_plc1, a2_plc2, a2_plc3));
    out(ch_2oo3_r2, (a2_plc1, a2_plc2, a2_plc3));
    out(ch_2oo3_r3, (a2_plc1, a2_plc2, a2_plc3));
    if a2_plc1 = a2_plc2 then out(ch_2oo3_s, a2_plc1);
    (* else if *) if a2_plc1 = a2_plc3 then out(ch_2oo3_s, a2_plc1);
    (* else if *) if a2_plc2 = a2_plc3 then out(ch_2oo3_s, a2_plc2).

(* recovery/netboot chip: reinstalls PLCx if misbehaving *)
let R(p: pkey,
      ch_2oo3_r: channel (* input *)
      ) =
    (* first iteration *)
    (* get values from PLCs *)
    in(ch_2oo3_r, (a1_plc1: int, a1_plc2: int, a1_plc3: int));

    lock state;
    new c: channel;
    state := (c, c, c, c, c, c);
    unlock state;

    (*if (a1_plc1 <> a1_plc2 && a1_plc2 = a1_plc3) then
        (* TODO: reset PLC1, switch sensor/2oo3 to it? *)
    (*if (a1_plc2 <> a1_plc1 && a1_plc1 = a1_plc3) then
       (* TODO: reset PLC2 *)
    (*if (a1_plc3 <> a1_plc1 && a1_plc1 = a1_plc2) then
       (* TODO: reset PLC3 *)
    (* second iteration *)
    phase 1;
    (* TODO *)
    (*in(ch_2oo3_r, (a2_plc1: int, a2_plc2: int, a2_plc3: int));*)
    0.

process
   (* start sensor/actuator *)
   sensor_actuator() |
   (* start PLC1, PLC2, and PLC3 *)
   PLC(k1, plc1, ch_s_plc1, ch_plc1_2oo3) |
   PLC(k2, plc2, ch_s_plc2, ch_plc2_2oo3) |
   PLC(k3, plc3, ch_s_plc3, ch_plc3_2oo3) |
   (* start circuit 2oo3 *)
   c_2oo3(ch_2oo3_r1, ch_2oo3_r2, ch_2oo3_r3)
