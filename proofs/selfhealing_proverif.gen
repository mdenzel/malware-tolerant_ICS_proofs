(*
#if FALSE

  @title:    Self-healing Industrial Control System
  @authors:  Michael Denzel
  @date:     2016-07-14

  Warning: this is a raw file to generate ProVerif proofs.
  It includes C-macros and is not intended to be run directly.
  Please use the appended shellscript to generate the code.

#else
  GENERATED FILE

  @title:    Self-healing Industrial Control System
  @authors:  Michael Denzel
  @date:     __DATE__

#endif
*)

(* ###################### CONFIG SECTION ###################### *)
(*set reconstructTrace = true. (* REMARK: traces sometimes cannot be created;
                                         rather use proof output *)
(*set verboseRules = true. (* print every single rule *)
(*set explainDerivation = false.*)
(* ############################################################ *)

(* defines *)
type int.

(* #################### XXX: trust model #################### *)
    (* global variables *)
    const policy:       bool.
    const plc1:         int.
    const plc2:         int.
    const plc3:         int.

    (* channels *)
    (* sensor/actuator is always honest since this is the device we protect *)
    (* => no channels here *)

    (* PLC1 *)
#if (PLC1_COMPR)
    free ch_s_plc1:     channel .          (* plc1 compromised *)
#else
    free ch_s_plc1:     channel [private]. (* plc1 honest *)
#endif
#if (PLC1_COMPR || _2oo3_COMPR)
    free ch_plc1_2oo3:  channel .          (* plc1 or 2oo3 compromised *)
#else
    free ch_plc1_2oo3:  channel [private]. (* plc1 and 2oo3 honest *)
#endif

    (* PLC2 *)
#if (PLC2_COMPR)
    free ch_s_plc2:     channel .          (* plc2 compromised *)
#else
    free ch_s_plc2:     channel [private]. (* plc2 honest *)
#endif
#if (PLC2_COMPR || _2oo3_COMPR)
    free ch_plc2_2oo3:  channel .          (* plc2 or 2oo3 compromised *)
#else
    free ch_plc2_2oo3:  channel [private]. (* plc2 and 2oo3 honest *)
#endif

    (* PLC3 *)
#if (PLC3_COMPR)
    free ch_s_plc3:     channel .          (* plc3 compromised *)
#else
    free ch_s_plc3:     channel [private]. (* plc3 honest *)
#endif
#if (PLC3_COMPR || _2oo3_COMPR)
    free ch_plc3_2oo3:  channel .          (* plc3 or 2oo3 compromised *)
#else
    free ch_plc3_2oo3:  channel [private]. (* plc3 and 2oo3 honest *)
#endif

    (* 2oo3 *)
#if (_2oo3_COMPR)
   free ch_2oo3_s:      channel .          (* 2oo3 compromised *)
#else
   free ch_2oo3_s:      channel [private]. (* 2oo3 honest *)
#endif

    (* R1 *)
#if (R1_COMPR || _2oo3_COMPR)
   free ch_2oo3_r1:     channel .          (* R1 or 2oo3 compromised *)
   free ch_r1_2oo3:     channel .          (* R1 or 2oo3 compromised *)
#else
   free ch_2oo3_r1:     channel [private]. (* R1 and 2oo3 honest *)
   free ch_r1_2oo3:     channel [private]. (* R1 and 2oo3 honest *)
#endif
#if (R1_COMPR)
   free ch_r1_s:        channel .          (* R1 compromised *)
#else
   free ch_r1_s:        channel [private]. (* R1 honest *)
#endif

    (* R2 *)
#if (R2_COMPR || _2oo3_COMPR)
   free ch_2oo3_r2:     channel .          (* R2 or 2oo3 compromised *)
   free ch_r2_2oo3:     channel .          (* R2 or 2oo3 compromised *)
#else
   free ch_2oo3_r2:     channel [private]. (* R2 and 2oo3 honest *)
   free ch_r2_2oo3:     channel [private]. (* R2 and 2oo3 honest *)
#endif
#if (R2_COMPR)
   free ch_r2_s:        channel .          (* R2 compromised *)
#else
   free ch_r2_s:        channel [private]. (* R2 honest *)
#endif


    (* R3 *)
#if (R3_COMPR || _2oo3_COMPR)
   free ch_2oo3_r3:     channel .          (* R3 or 2oo3 compromised *)
   free ch_r3_2oo3:     channel .          (* R3 or 2oo3 compromised *)
#else
   free ch_2oo3_r3:     channel [private]. (* R3 and 2oo3 honest *)
   free ch_r3_2oo3:     channel [private]. (* R3 and 2oo3 honest *)
#endif
#if (R3_COMPR)
   free ch_r3_s:        channel .          (* R3 compromised *)
#else
   free ch_r3_s:        channel [private]. (* R3 honest *)
#endif


(* ############################################################ *)


(* test variables to check if end of protocol etc. is reached *)
free success: bitstring [private].
free ch_pub: channel. (* public channel *)

(* events to define control flows *)
event sensor_start(bool).
event a1_result(bool).
event a2_result(bool).
(* misbehaving PLCs *)
event result_ok(int, bool).
event reset(int).
event not_reset(int).

(* #################### XXX: QUERIES #################### *)
(* protocol runs through *)
(* "not attacker(success)" should be false/cannot be proved! *)
query attacker(success).

(* correct control of sensor/actuator *)
(*
   Queries read:
   If a2 is correct, then a1 is.
   If a1 is correct, then sensor_start is.
   Since sensor_start can only have sensor_start(policy)
   and success is reachable (above!), there can only be
   a1(policy) and a2(policy).
*)
query b:bool;
      (event (a2_result(b)) ==> event (a1_result(b))).
query b:bool;
      (event (a1_result(b)) ==> event (sensor_start(b))).

(* self-healing *)
(* 
   ATTENTION: Queries have to be read in negative form:
   X => Y means: for all X, Y happened;
   an attack would be: there is a Y where not X, or X without Y.

   For the queries, we have a binary event reset/not_reset.
   Reset(plc_i) => result_ok(plc_i, misbehaving) means if we have a reset, plc1 misbehaved.
   Attacks are either:
   - reset is reachable without result_ok
   - there is result_ok(plc_i, honest) and reset(plc_i)
   => so this proves the absence of plc_i behaved correctly but reset happend (Type I Error).
*)
query i:int, b:bool, x:bool;
      event (reset(i)) ==> (event (result_ok(i, x)) && event (sensor_start(b)) && x<>b).
(*
   not_reset(plc_i) => result_ok(plc_i, correct) means:
   For all not_reset, plc_i was behaving correctly.
   Attacks:
   - not_reset reachable without result_ok
   - there is result_ok(plc_i, misbehaving) and not_reset(plc_i)
   => proves absence of plc_i misbehaving but no reset (Type II Error).

   Combining Type I and Type II Error we get:
   "Only if plc_i misbehaved, a reset will happen"
*)
query i:int, b:bool;
      event (not_reset(i)) ==> (event (result_ok(i, b)) && event (sensor_start(b))).
      

(* ###################################################### *)


(* sensor: generates (reads) new sensor value s *)
let sensor_actuator(ch_r1_s: channel, ch_r2_s: channel, ch_r3_s: channel) =
    new s1: bool;
    event sensor_start(not(not(policy)));
    (* first iteration *)
    out(ch_s_plc1, (policy, s1));
    out(ch_s_plc2, (policy, s1));
    out(ch_s_plc3, (policy, s1));
    out(ch_pub, (policy, s1)); (* tell attacker *)
    in(ch_2oo3_s, a1: bool); (* PLCs calculate: policy XOR s1 *)
    let r1 = (s1 || a1) && not(s1 && a1) in (* s1 XOR a1 = s1 XOR policy XOR s1 = policy *)
    event a1_result(r1);
    (* second iteration *)
    phase 1;
    (* get new channels from reset circuits *)
    in(ch_r1_s, ch_s_plc1_new: channel);
    in(ch_r2_s, ch_s_plc2_new: channel);
    in(ch_r3_s, ch_s_plc3_new: channel);
    (* work with channels *)
    new s2: bool;
    let n = r1 in
    out(ch_s_plc1_new, (n, s2));
    out(ch_s_plc2_new, (n, s2));
    out(ch_s_plc3_new, (n, s2));
    out(ch_pub, (n, s2)); (* tell attacker *)
    in(ch_2oo3_s, a2: bool); (* PLCs calculate: n XOR s2 *)
    event a2_result((s2 || a2) && not(s2 && a2)); (* s2 XOR a2 = s2 XOR n XOR s2 = n (should be policy) *)
    (* done *)
    out(ch_pub, success).

(* programmable logic controller: calculates actuator value *)
let PLC(
        ch_s_plc: channel, (* input *)
        ch_plc_2oo3: channel (* output *)
        ) =
    (* first iteration *)
    in(ch_s_plc, (n1: bool, s1: bool));
    let a1 = (n1 || s1) && not(n1 && s1) in
    out(ch_plc_2oo3, a1);
    (* second iteration *)
    phase 1;
    in(ch_s_plc, (n2: bool, s2: bool));
    let a2 = (n2 || s2) && not(n2 && s2) in
    out(ch_plc_2oo3, a2).

let PLC_new(
        ch_s_plc: channel, (* input *)
        ch_plc_2oo3: channel (* output *)
        ) =
    phase 1;
    in(ch_s_plc, (n2: bool, s2: bool));
    let a2 = (n2 || s2) && not(n2 && s2) in
    out(ch_plc_2oo3, a2).

(* two-out-of-three circuit: combines results of PLCs *)
let c_2oo3(
        ch_r1_2oo3: channel, ch_r2_2oo3: channel, ch_r3_2oo3: channel, (* input *)
        ch_2oo3_r1: channel, ch_2oo3_r2: channel, ch_2oo3_r3: channel  (* output *)
        ) =
    (* first iteration *)
    in(ch_plc1_2oo3, a1_plc1: bool);
    in(ch_plc2_2oo3, a1_plc2: bool);
    in(ch_plc3_2oo3, a1_plc3: bool);
    (* usually a1 would be signed here
    and normally go via the historian(s) *)
    let a1 = (a1_plc1 && a1_plc2) || (a1_plc1 && a1_plc3) || (a1_plc2 && a1_plc3) in
    let a1_xnor1 = (a1_plc1 && a1_plc2) || (not(a1_plc1) && not(a1_plc2)) in
    let a1_xnor2 = (a1_plc1 && a1_plc3) || (not(a1_plc1) && not(a1_plc3)) in
    let a1_xnor = a1_xnor1 || a1_xnor2 in
    event result_ok(plc1, not(not(a1_plc1)));
    event result_ok(plc2, not(not(a1_plc2)));
    event result_ok(plc3, not(not(a1_plc3)));
    out(ch_2oo3_r1, (a1_plc1, a1_plc2, a1_plc3));
    out(ch_2oo3_r2, (a1_plc2, a1_plc1, a1_plc3));
    out(ch_2oo3_r3, (a1_plc3, a1_plc1, a1_plc2));
    out(ch_2oo3_s, a1);
    (* second iteration *)
    phase 1;
    (* get new channels from reset circuits *)
    in(ch_r1_2oo3, ch_plc1_2oo3_new: channel);
    in(ch_r2_2oo3, ch_plc2_2oo3_new: channel);
    in(ch_r3_2oo3, ch_plc3_2oo3_new: channel);
    (* work with new channels *)
    in(ch_plc1_2oo3_new, a2_plc1: bool);
    in(ch_plc2_2oo3_new, a2_plc2: bool);
    in(ch_plc3_2oo3_new, a2_plc3: bool);
    (* usually a1 would be signed here
    and normally go via the historian(s) *)
    (* reset circuit skipped because it would take effect in non-existent third iteration*)
    let a2 = (a2_plc1 && a2_plc2) || (a2_plc1 && a2_plc3) || (a2_plc2 && a2_plc3) in
    let a2_xnor1 = (a2_plc1 && a2_plc2) || (not(a2_plc1) && not(a2_plc2)) in
    let a2_xnor2 = (a2_plc1 && a2_plc3) || (not(a2_plc1) && not(a2_plc3)) in
    out(ch_2oo3_s, a2).

(* recovery/netboot chip: reinstalls PLCx if misbehaving *)
let R(ch_2oo3_r: channel, (* input *)
      ch_s_own: channel, ch_own_2oo3: channel, plc_num: int, (* values of own PLC *)
      ch_r_s: channel, ch_r_2oo3: channel (* output *)
      ) =
    (* first iteration *)
    (* get values from PLCs *)
    in(ch_2oo3_r, (a1_own: bool, a1_other1: bool, a1_other2: bool));
    if ((not(not(a1_own)) = not(not(a1_other1)) && not(not(a1_own)) = not(not(a1_other2))) || not(not(a1_other1)) <> not(not(a1_other2))) then
        (* everything ok *)
        event not_reset(plc_num);
        phase 1;
        out(ch_r_s, ch_s_own);
        out(ch_r_2oo3, ch_own_2oo3)
    else
        (* own PLC was misbehaving => reset it *)
        event reset(plc_num);
        (* create new channel *)
        new ch_s_new: channel;
        new ch_new_2oo3: channel;
        (* create PLC_new *)
        PLC_new(ch_s_new, ch_new_2oo3) |
        (* tell the others *)
        phase 1;
        out(ch_r_s, ch_s_new);
        out(ch_r_2oo3, ch_new_2oo3).
    (* second iteration not needed as changes would only affect the third iteration
       which is not modelled *)

process
   (* start sensor/actuator *)
   sensor_actuator(ch_r1_s, ch_r2_s, ch_r3_s) |
   (* start PLC1, PLC2, and PLC3 *)
   PLC(ch_s_plc1, ch_plc1_2oo3) |
   PLC(ch_s_plc2, ch_plc2_2oo3) |
   PLC(ch_s_plc3, ch_plc3_2oo3) |
   (* start R1, R2, and R3 *)
   R(ch_2oo3_r1, ch_s_plc1, ch_plc1_2oo3, plc1, ch_r1_s, ch_r1_2oo3) |
   R(ch_2oo3_r2, ch_s_plc2, ch_plc2_2oo3, plc2, ch_r2_s, ch_r2_2oo3) |
   R(ch_2oo3_r3, ch_s_plc3, ch_plc3_2oo3, plc3, ch_r3_s, ch_r3_2oo3) |
   (* start circuit 2oo3 *)
   c_2oo3(ch_r1_2oo3, ch_r2_2oo3, ch_r3_2oo3,
          ch_2oo3_r1, ch_2oo3_r2, ch_2oo3_r3)
